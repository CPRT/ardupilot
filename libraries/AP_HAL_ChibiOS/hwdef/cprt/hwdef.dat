# hw definition file for processing by chibios_hwdef.py
# for FMUv3 hardware (ie. for Pixhawk1, Pixhawk2 cube, XUAV2.1 etc)

# This hwdef.dat file contains a lot of comments so it act as a
# reference for developers adding new boards.

# The hwdef.dat file defines all the hardware peripherals and pins for
# a port of ArduPilot to a board using the ChibiOS HAL. You should be
# able to write the hwdef.dat file for a new board with just the
# schematic for the board.

# This file is processed by chibios_hwdef.py to create hwdef.h for
# this board. You may find it useful to run chibios_hwdef.py manually
# when building this file for a new board. The resulting hwdef.h file
# is formatted to make it quite readable. It is strongly suggested
# that you read the resulting hwdef.h file when porting to a new board
# to make sure it has resulted in what you want.

# You should read this file in conjunction with the schematic for your
# board, the datasheet for the MCU for your board and the python
# tables file that we have extracted from the datasheet for your
# MCU. The python tables file is particularly important, so if you
# haven't seen it before go and look at it now. For the STM32F427 it
# it called STM32F427xx.py and it is in the hwdef/script/ directory
# inside the HAL_ChibiOS directory. That file tells you what each pin
# can do (the alternate functions table) and what DMA channels can be
# used for each peripheral type. The alternative functions table is
# particularly useful when doing a new hwdef.dat file as you can work
# out peripheral numbers given a port/pin name.

# We need to start off by saying what main CPU is on the board. There
# are two CPU identifiers that you need to specify. The first is the
# ChibiOS MCU type. So far we only support STM32F4xx for all STM32F4
# board types. In the future we will add F7 and other MCU types
# The second string needs to match the name of a config file in the
# libraries/AP_HAL_ChibiOS/hwdef/script directory. In this case we are
# using a F427 MCU, so we select STM32F427xx to match the
# STM32F427xx.py file in the script directory. If you are supporting a
# board type that doesn't have a python hardware database file yet
# then you will need to create one. There are scripts in the scripts
# directory to help with that by parsing the STM32 datasheets to
# extract the required DMA and alternate function tables.

# MCU class and specific type
MCU STM32H7xx STM32H743xx

# Now we need to specify the APJ_BOARD_ID. This is the ID that the
# bootloader presents to GCS software so it knows if this firmware is
# suitable for the board. Please see
# https://github.com/ArduPilot/Bootloader/blob/master/hw_config.h for
# a list of current board IDs. If you add a new board type then please
# get it added to that repository so we don't get conflicts.

# Note that APJ is "ArduPilot JSON Firmware Format".

# board ID. See Tools/AP_Bootloader/board_types.txt
APJ_BOARD_ID TARGET_HW_CUBE_F4

# Now you need to say what crystal frequency you have for this
# board. All of the clocks are scaled against this. Typical values are
# 24000000 or 8000000.

# crystal frequency
OSCILLATOR_HZ 16000000

# On some boards you will need to also set the various PLL values. See
# the defaults in common/mcuconf.h, and use the define mechanism
# explained later in this file to override values suitable for your
# board. Refer to your MCU datasheet or examples from supported boards
# in ChibiOS for the right values.

# This is the STM32 timer that ChibiOS will use for the low level
# driver. This must be a 32 bit timer. We currently only support
# timers 2, 3, 4, 5 and 21. See hal_st_lld.c in ChibiOS for details.

# ChibiOS system timer
STM32_ST_USE_TIMER 5

# Now the size of flash in kilobytes, for creating the ld.script.

# flash size
FLASH_SIZE_KB 2048

# Now the USB setup, if you have USB. All of these settings are
# option, and the ones below are the defaults. It ends up creating a
# USB ID on Linux like this:
# /dev/serial/by-id/usb-ArduPilot_fmuv3_3E0031000B51353233343932-if00
# If creating a board for a RTF vehicle you may wish to customise these.

# USB setup
USB_STRING_MANUFACTURER "ArduPilot"

# Now define the order that I2C buses are presented in the hal.i2c API
# in ArduPilot. For historical reasons inherited from HAL_PX4 the
# 'external' I2C bus should be bus 1 in hal.i2c, and internal I2C bus
# should be bus 0. On fmuv3 the STM32 I2C1 is our external bus and
# I2C2 is our internal bus, so we need to setup the order as I2C2
# followed by I2C1 in order to achieve the conventional order that
# drivers expect.

# order of I2C buses
I2C_ORDER I2C1 I2C2 I2C4

# Now the serial ordering. These map to the SERIALn_ parameter numbers
# If you use a shorter list then HAL_Empty::UARTDriver
# objects are substituted for later UARTs, or you can leave a gap by
# listing one or more of the uarts as EMPTY.

# The normal usage of this ordering is:
# 1) SERIAL0: console (primary mavlink, usually USB)
# 2) SERIAL1: telem1
# 3) SERIAL2: telem2
# 4) SERIAL3: primary GPS
# 5) SERIAL4: GPS2
# 6) SERIAL5: extra UART (usually RTOS debug console)

# order of UARTs (and USB)
SERIAL_ORDER OTG1 USART2 UART4 USART3 UART7 UART5

# UART
PC10 UART4_TX UART4
PC11 UART4_RX UART4
PC12 UART5_TX UART5
PB12 UART5_RX UART5

# Now the VDD sense pin. This is used to sense primary board voltage.
PC0 VDD_5V_SENS ADC1 SCALE(2)

# Now the first SPI bus. At minimum you need SCK, MISO and MOSI pin
definitions. You can add speed modifiers if you want them, otherwise
the defaults for the peripheral class are used.

PA5 SPI1_SCK SPI1
PA6 SPI1_MISO SPI1
PA7 SPI1_MOSI SPI1

# This is a commented out pin for talking to the debug UART on the
# IOMCU, not used yet, but left as a comment (with a '#' in front) for
# future reference
# PA10 IO-debug-console

# Now we define the pins that USB is connected on.
PA11 OTG_FS_DM OTG1
PA12 OTG_FS_DP OTG1

# These are the pins for SWD debugging with a STlinkv2 or black-magic probe.
PA13 JTMS-SWDIO SWD
PA14 JTCK-SWCLK SWD

# This defines a couple of general purpose outputs, mapped to GPIO
# numbers 1 and 2 for users.
PB0 EXTERN_GPIO1 OUTPUT GPIO(1)
PB1 EXTERN_GPIO2 OUTPUT GPIO(2)

# This defines the pins for the 2nd CAN interface, if available.
PB6 CAN2_TX CAN2
PB5 CAN2_RX CAN2

# Now the first I2C bus. The pin speeds are automatically setup
# correctly, but can be overridden here if needed.
PB8 I2C1_SCL I2C1
PB9 I2C1_SDA I2C1

# the 2nd I2C bus
PB10 I2C2_SCL I2C2
PB11 I2C2_SDA I2C2

PD12 I2C4_SCL I2C4
PD13 I2C4_SDA I2C4

# the 2nd SPI bus
PB13 SPI2_SCK SPI2
PC2 SPI2_MISO SPI2
PC3 SPI2_MOSI SPI2
PE15 EXT_CS CS

# This defines the CS pin for the magnetometer and first IMU. Note
# that CS pins are software controlled, and are not tied to a particular
# SPI bus.
PE3 MPU_CS CS

# More CS pins for more sensors. The labels for all CS pins need to
# match the SPI device table later in this file.
PE4 MPU_EXT_CS CS

# the first CAN bus
PD0  CAN1_RX CAN1
PD1  CAN1_TX CAN1

# Another USART, this one for telem1. This one has RTS and CTS lines.
# USART2 serial2 telem1
PD3 USART2_CTS USART2
PD4 USART2_RTS USART2
PD5 USART2_TX USART2
PD6 USART2_RX USART2

# The telem2 USART, also with RTS/CTS available.
# USART3 serial3 telem2
PD8 USART3_TX USART3
PD9 USART3_RX USART3

# The CS pin for FRAM (ramtron). This one is marked as using
# SPEED_VERYLOW, which matches the HAL_PX4 setup.
PA4 FRAM_CS CS SPEED_VERYLOW

# Now we start defining some PWM pins. We also map these pins to GPIO
# values, so users can set BRD_PWM_COUNT to choose how many of the PWM
# outputs on the primary MCU are setup as PWM and how many as
# GPIOs. To match HAL_PX4 we number the GPIOs for the PWM outputs
# starting at 50.

PA9  TIM1_CH2 TIM1 PWM(1) GPIO(50)
PA8  TIM1_CH1 TIM1 PWM(2) GPIO(51)
PC9 TIM3_CH4 TIM3 PWM(3) GPIO(52)
PC8 TIM3_CH3 TIM3 PWM(4) GPIO(53)
PC7 TIM3_CH2 TIM3 PWM(5) GPIO(54)
PC6 TIM3_CH1 TIM3 PWM(6) GPIO(55)
PD15 TIM4_CH4 TIM4 PWM(7) GPIO(56)
PD14 TIM4_CH3 TIM4 PWM(8) GPIO(57)

# Now setup SPI bus4.
PE2 SPI4_SCK  SPI4
PE5 SPI4_MISO SPI4
PE6 SPI4_MOSI SPI4

# This is the pin to enable the sensors rail. It can be used to power
# cycle sensors to recover them in case there are problems with power on
# timing affecting sensor stability. We pull it high by default.
PE0 VDD_3V3_SENSORS_EN OUTPUT HIGH

# UART7 maps to SERIAL5.
PE7 UART7_RX UART7
PE8 UART7_TX UART7
PE9 UART7_RTS UART7
PE10 UART7_CTS UART7

# microSD support
PB14 SDMMC2_D0 SDMMC1
PB15 SDMMC2_D1 SDMMC1
PC1 SDMMC2_CK SDMMC1
PB3 SDMMC2_D2 SDMMC1
PB4 SDMMC2_D3 SDMMC1
PD7 SDMMC2_CMD SDMMC1

# red LED marked as B/E
PA2 LED_RED OUTPUT OPENDRAIN GPIO(90)

# green LED marked as PWR. We leave this solid on, but allow
# for it to be controlled as a relay if needed
PA3 LED_GREEN OUTPUT GPIO(91) LOW

# blue LED marked as ACT
PA1 LED_BLUE OUTPUT GPIO(92) HIGH

# setup for BoardLED2
define AP_NOTIFY_GPIO_LED_2_ENABLED 1
define HAL_GPIO_A_LED_PIN 90
define HAL_GPIO_B_LED_PIN 92

# The DEVID values and device names are chosen to match the PX4 port
# of ArduPilot so users don't need to re-do their accel and compass
# calibrations when moving to ChibiOS.

SPIDEV icm45686-2     SPI1 DEVID1  MPU_CS       MODE3  2*MHZ  8*MHZ
SPIDEV icm45686       SPI4 DEVID1  MPU_EXT_CS   MODE3  2*MHZ  8*MHZ
SPIDEV ramtron        SPI2 DEVID10 FRAM_CS      MODE3  8*MHZ  8*MHZ

# We need to tell HAL_ChibiOS/Storage.cpp how much storage is
# available (in bytes).
define HAL_STORAGE_SIZE 32768

# allow to have have a dedicated safety switch pin
define HAL_HAVE_SAFETY_SWITCH 1

# This enables the use of a ramtron device for storage, if one is
# found on SPI. You must have a ramtron entry in the SPI device table.

# Enable RAMTRON parameter storage.
define HAL_WITH_RAMTRON 1

# Enable FAT filesystem support (needs a microSD defined via SDIO).
define HAL_OS_FATFS_IO 1

# This defines the default maximum clock on I2C devices.
define HAL_I2C_MAX_CLOCK 100000
